# \MODULE\-------------------------------------------------------------------------
#
#  CONTENTS      : BumbleBee
#
#  DESCRIPTION   : Nanopore Basecalling
#
#  RESTRICTIONS  : none
#
#  REQUIRES      : none
#
# ---------------------------------------------------------------------------------
# Copyright [2019] [Pay Giesselmann, Max Planck Institute for Molecular Genetics]
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Written by Pay Giesselmann
# ---------------------------------------------------------------------------------
import os, sys
from snakemake.io import glob_wildcards
from snakemake.utils import min_version


min_version("5.4.0")
configfile: "config.yaml"
localrules: tag_run, tag_tag




# append username to shadow prefix if not present
if hasattr(workflow, "shadow_prefix") and workflow.shadow_prefix:
    shadow_prefix = workflow.shadow_prefix
    if not os.environ['USER'] in shadow_prefix:
        shadow_prefix = os.path.join(shadow_prefix, os.environ['USER'])
        print("[INFO] Shadow prefix is changed from {p1} to {p2} to be user-specific".format(
            p1=workflow.shadow_prefix, p2=shadow_prefix), file=sys.stderr)
    workflow.shadow_prefix = shadow_prefix
    print("Shadow prefix: " + shadow_prefix, file=sys.stderr)




def get_tag_barcode(tag):
    bcs = [config['barcode_map'][bc] for bc in config['barcode_map'].keys() if bc in tag]
    return bcs[-1]




def get_raw_batch(wildcards):
    prefix = '{raw}/{runname}/reads/{batch}'.format(
        raw=config['storage_data_raw'],
        runname=wildcards.runname,
        batch=wildcards.batch)
    if os.path.isfile(prefix + '.fast5'):
        return prefix + '.fast5'
    elif os.path.isfile(prefix + '.tar'):
        return prefix + '.tar'
    else:
        return 'demux/guppy/barcodes/{runname}/{barcode}/{batch}.txt'.format(
            runname=wildcards.runname,
            barcode=get_tag_barcode(wildcards.tag),
            batch=wildcards.batch)




rule segmentation:
    input:
        raw = lambda wildcards : get_raw_batch(wildcards),
        bam = "alignments/{aligner}/{sequence_workflow}/batches/{tag}/{runname}/{batch}.{reference}.bam",
        bai = "alignments/{aligner}/{sequence_workflow}/batches/{tag}/{runname}/{batch}.{reference}.bam.bai"
    output:
        tfrec = "segments/{aligner, [^.\/]*}/{sequence_workflow}/batches/{tag, [^\/]*}/{runname, [^\/]*}/{batch}.{reference}.tfrec"
    params:
        index = lambda wildcards : '--index ' + os.path.join(config['storage_data_raw'], wildcards.runname, 'reads.fofn')
    threads: 32
    resources:
        mem_mb = lambda wildcards, threads, attempt : int(threads * 2000),
        time_min = lambda wildcards, threads, attempt : int((3840 / threads) * attempt)
    shadow: 'minimal'
    shell:
        """
        mkdir raw
        {config[py_env]}/bin/python3 {config[storage_fast5Index]} extract {input.raw} raw/ {params.index} --output_format bulk
        /project/minion/bin/samtools view -F 2308 {input.bam} | {config[py_env]}/bin/python3 {config[segmentation_script]} {config[pore_model]} `ls raw/*.fast5` {output.tfrec} --slicer 8 --mapper {threads}
        """




rule events:
    input:
        raw = lambda wildcards : get_raw_batch(wildcards),
        bam = "alignments/{aligner}/{sequence_workflow}/batches/{tag}/{runname}/{batch}.{reference}.bam",
        bai = "alignments/{aligner}/{sequence_workflow}/batches/{tag}/{runname}/{batch}.{reference}.bam.bai",
        reference = lambda wildcards: config['references'][wildcards.reference]['genome']
    output:
        tfrec = "events/{aligner, [^.\/]*}/{sequence_workflow, ((?!batches).)*}/batches/{tag, [^\/]*}/{runname, [^\/]*}/{batch}.{reference}.tfrec"
    params:
        index = lambda wildcards : '--index ' + os.path.join(config['storage_data_raw'], wildcards.runname, 'reads.fofn'),
    threads: 1
    resources:
        mem_mb = 16000,
        time_min = 240
    shadow: 'minimal'
    shell:
        """
        mkdir raw
        {config[py_env]}/bin/python3 {config[storage_fast5Index]} extract {input.raw} raw/ {params.index} --output_format bulk
        /project/minion/bin/samtools view -bF 2308 {input.bam} | bedtools bamtobed -i stdin | bedtools getfasta -fi {input.reference} -bed stdin -name -s | sed 's/(.)//' > reads.fasta
        {config[py_env]}/bin/python3 {config[event_script]} {config[pore_model]} `ls raw/*.fast5` reads.fasta {output.tfrec}
        """




rule tag_run:
    input:
        hdf5 = lambda wildcards : expand("{mode}/{aligner}/{sequence_workflow}/batches/{tag}/{runname}/{batch}.{reference}.tfrec",
                        mode = wildcards.mode,
                        aligner = wildcards.aligner,
                        sequence_workflow = wildcards.sequence_workflow,
                        tag = wildcards.tag,
                        runname = wildcards.runname,
                        batch = glob_wildcards(
                            "alignments/{aligner}/{sequence_workflow}/batches/{tag}/{runname}/{{batch}}.{reference}.bam".format(
                                aligner = wildcards.aligner,
                                sequence_workflow = wildcards.sequence_workflow,
                                tag = wildcards.tag,
                                runname = wildcards.runname,
                                reference = wildcards.reference))[0],
                        reference = wildcards.reference)
    output:
        tag = temp("{mode, [^.\/]*}/{aligner, [^.\/]*}/{sequence_workflow, ((?!batches).)*}/batches/{tag, [^\/]*}/{runname, [^\/]*}.{reference}.events")
    shell:
        "touch {output.tag}"


rule tag_tag:
    input:
        tags = lambda wildcards : ["{mode}/{aligner}/{sequence_workflow}/batches/{tag}/{runname}.{reference}.events".format(
                mode=wildcards.mode,
                aligner=wildcards.aligner,
                sequence_workflow=wildcards.sequence_workflow,
                tag=tag,
                runname=runname,
                reference=wildcards.reference)
            for tag, runnames in config['tag_map'].items() for runname in runnames]
    output:
        tag = touch("{mode, [^.\/]*}/{aligner, [^.\/]*}/{sequence_workflow, ((?!batches).)*}/{tag, [^\/]*}.{reference, [^.]*}.events")
